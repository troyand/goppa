\documentclass[a4paper,12pt,oneside]{article}
\usepackage[left=30mm,right=15mm,top=20mm,bottom=20mm,includefoot]{geometry}
\usepackage[small,compact,center]{titlesec}
\usepackage{setspace}
\onehalfspacing
\usepackage[utf8]{inputenc}
\usepackage[english,ukrainian]{babel}
\usepackage{verbatim}
\usepackage{indentfirst}
\usepackage{fullpage}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{cases}
\usepackage{graphicx}
\usepackage{cite}

\title{Курсова робота\\Надлишкове кодування на еліптичних кривих}
\author{Михайло Трояновський}

\begin{document}

\begin{titlepage}
\begin{center}
Національний Університет\\ «Києво-Могилянська Академія»\\
        Кафедра математики\\
        \vskip 3cm
        \includegraphics[width=100mm]{kma}\\
                               \vskip 1cm
{\Large
    Курсова робота на тему:\\
        «Надлишкове кодування на еліптичних кривих»
}
\vskip 1cm
\hskip 0.5\textwidth
\begin{minipage}{0.5\textwidth}
\textbf{Виконав:}\\
        Михайло Михайлович Трояновський, студент ІСПР–1\\
        \\
        \textbf{Науковий керівник:}\\
        Юрій Вікторович Боднарчук
        \end{minipage}
        \vfill
        Київ–2010
        \end{center}
        \end{titlepage}


\tableofcontents
\pagebreak

\section{Вступ}
Надлишкове кодування відіграє значну роль у боротьбі з помилками, які виникають при передачі даних через зашумлені телекомунікаційне середовище. 
Загалом для надійної передачі інформації через ненадійні канали застосовують дві стратегії: виявлення та виправлення помилок. 
У першому випадку до блоку даних додають контрольну інформацію, за допомогою якої одержувач має змогу зрозуміти, 
що під час зв'язку відбулося пошкодження відповідного блоку, тому необхідно зробити запит на повторну передачу. 
Найпростішим прикладом такої контрольної інформації є біт парності, який додається до блоку бінарних даних таким чином, аби загальна кількість одиниць у блоці була парною. 
Це дає можливість одержувачу виявити помилку в одному біті переданого блоку, проте якщо помилок було більше, вони можуть скасувати одна одну; 
втім подібний метод можна досить просто узагальнити для виявлення будь-якої непарної кількості помилок.

Проте існують застосування, у яких одного виявлення факту помилки при передачі інформації замало, оскільки повторна передача блоку даних може бути занадто витратною: 
так при зв'язку із об'єктами у космосі, що віддалені від Землі на велику відстань існує значна затримка, яка буде лише збільшуватися при ретрансмісії; 
при односторонній передачі даних (наприклад, у телемовленні) ретрансмісія взагалі технічно неможлива. 
У таких випадках необхідно намагатися виправляти помилки наперед, додаючи до блоку даних надлишкову інформацію, яка дозволятиме одержувачу відновити блок навіть за наявності помилок передачі. 
Простим прикладом даного підходу може бути таке бінарне кодування: кожен біт передається тричі підряд, одержувач аналізує триплети та декодує їх у той біт, якого кількісно більше у триплеті. 
Зрозуміло, що такий спосіб дозволяє виправити одну помилку в окремому триплеті, але ціна такої можливості досить велика: дані за такого підходу будуть передаватися втричі повільніше.

Природнім є бажання знайти способи надлишкового кодування, які з одного боку дозволятимуть виправляти значну кількість помилок, а з іншого боку не призводить до сповільнення передачі. 
Розвиненою в цьому аспекті є теорія лінійних кодів, де були встановлені нерівності, які дають можливість порівняти різні кодування між собою, 
а також обирати для практичного використання коду із граничними характеристиками. 
Зокрема, важливою є границя Сінглтона, яка стверджує, що для лінійного $(n, k, d)$-коду справжується нерівність: $d \le n-k+1$. 
Код який досягає відповідної рівності, називають кодом із максимально досяжною мінімальною відстанню, нетривіальним прикладом такого випадку слугують коди Ріда-Соломона.

Однак у теорії лінійних кодів також є проблемні місця. Так, у загальному випадку алгоритм декодування, а також визначення мінімальної дистанції лінійного коду є NP-складними. 
Тому для практичного використання необхідно використовувати коди зі специфічними властивостями, які дозволятимуть їх ефективно декодувати. 
У цій роботі описано алгебро-геометричні коди, для яких з одного боку відомий швидкий алгоритм декодування, 
а з іншого боку була доведена можливість перевершення цими кодами границі Варшамова-Гілберта.

\section{Постановка задачі}
Мета даної курсової роботи -- описати наявні способи надлишкового кодування з використанням еліптичних кривих, а також їхні переваги у порівнянні з іншими кодами.

\section{Основні поняття}

\subsection{Лінійні коди}
Лінійний код --- векторний підпростір $C$ розмірності $k$ векторного простору $\mathbb{F}_q^n$ розмірності $n$, де $\mathbb{F}_q$ --- скінченне поле із $q$ елементів. 
$d$ --- мінімальна відстань за Хемінгом між кодовими словами. Максимальна кількість помилок, які може виправити код: $r=\left \lfloor \frac{d-1}{2} \right \rfloor$. 
Підсумовуючи ці основні характеристики, часто кажуть про лінійний код як про $(n, k, d)_q$-код.

Нерівність Сінглтона: для $(n, k, d)$-коду виконується: $d \le n-k+1$, 
коди для яких виконується рівність $d = n-k+1$ називають кодами із максимально досяжною мінімальною відстанню (maximum distance separable), вони є у певному сенсі найкращими.

Нерівність Варшамова-Гілберта: якщо виконується співвідношення 
$$\sum_{i=1}^{d-1} C_{n-1}^i (q-1)^i < q^{n-k}$$
то існує лінійний $(n, k ,d)_q$-код.


\subsection{Афінні та проективні криві}

\subsection{Функціональні поля}

\subsection{Дивізори}
Дивізор алгебраїчної кривої $C$ --- це формальна сума її точок, взятих із певною кратністю:
$$D = \sum_{P \in C} n_P P, n_P \in \mathbb{Z},$$
де тільки скінченна кількість цілих чисел $n_P$ відмінна від нуля.

Множина усіх дивізорів, позначена як $\mathbb{D}$, формує Абелеву групу із законом додавання:
$$
\sum_{P \in C} n_P P + \sum_{P \in C} m_P P = \sum_{P \in C} (n_P + m_P) P
$$

Ступінь $D$ --- це цілочисельна сума його коефіцієнтів:
$$deg(D) = \sum_{P \in C} n_P$$
$\forall D_1, D_2 \in \mathbb{D}: deg(D_1) + deg(D_2) = deg(D_1 + D_2)$, тому відображення $deg: \mathbb{D} \to \mathbb{Z}$ є гомоморфізмом.
Множина $\mathbb{D}^0$ дивізорів ступеню 0 є підгрупою $D$, а також ядром гомоморфізму $deg$.

Порядок $D$ у точці $P$ --- це цілий коефіцієнт при $P$: $ord_P(D) = n_P$.

\section{Алгебро-геометричні коди}

\subsection{Приклад кодів Гоппи}
Нехай ми маємо криву $C$ над скінченним полем $\mathbb{F}$, скінченну множину точок $\mathcal{P} = \{P_1, \dots , P_n \}$ і дивізор $D$, відокремлений (disjoint) від $P_i$. 
Код Гоппи $GC = GC(\mathcal{P}, D, C)$ визначають як
$$GC = \{ (\phi(P_1), \dots , \phi(P_n)) | \phi \in L(D) \}$$
Зазначений запис є функціональним кодом. Код лишків визначають як
$$GC' = \{ c \in \mathbb{F}^n | c \cdot (\phi(P_1), \dots , \phi(P_n)) = 0, \forall \phi \in L(D) \}$$

Для прикладу нехай $C$ --- квадрика Клейна над $\mathbb{F}_5$, $\mathcal{P} = (0:1:0) + (0:0:1) + (3:4:1)$ і $D = 2 * (4:2:1) + 3 * (3:2:1)$.
Тоді $L(D)$ --- тривимірний простір із базисом
$$\phi_1(x, y) = \frac{xy+4}{y^2+y+4}, \phi_2(x, y) = \frac{y+2}{y+3}, \phi_3(x, y) = \frac{1}{y+3}$$
Тоді код Гоппи --- лінійний $(3, 2, 2)$-код над $\mathbb{F}_5$ із породжуючою матрицею
$$
\begin{pmatrix}
 1 & 0 & 2 \\
 0 & 1 & 4 
\end{pmatrix}
$$
Програмний код, який реалізує описаний вище приклад у математичному середовищі Magma:
\begin{verbatim}
> A<x,y> := AffineSpace(FiniteField(5),2);
> f:=x^3*y+y^3+x;
> C:=Curve(A,f);
> P1:=Places(C,1);
> Div := DivisorGroup(C);
> P1;
[
    Place at (0 : 1 : 0),
    Place at (0 : 0 : 1),
    Place at (1 : 0 : 0),
    Place at (4 : 2 : 1),
    Place at (3 : 2 : 1),
    Place at (3 : 4 : 1)
]
> D:=P1[2]+P1[3];
> P2:=[P1[1],P1[2],P1[6]];
> D:=2*P1[4]+3*P1[5];
> D0:=Div!D;
> D0;
Divisor on Curve over GF(5) defined by
x^3*y + x + y^3
> RiemannRochSpace(D0);
KModule of dimension 3 over GF(5)
Mapping from: KModule of dimension 3 over GF(5) to Algebraic function field
defined over GF(5) by
x^3*y + x + y^3
> Basis(D0);
[ ($.1*$.2 + 4)/($.2^2 + $.2 + 4), ($.2 + 2)/($.2 + 3), 1/($.2 + 3) ]
> GC:=AlgebraicGeometricCode(P2,D0);
> GC;
[3, 2, 2] Linear Code over GF(5)
Generator matrix:
[1 0 2]
[0 1 4]
\end{verbatim}


\nocite{*}

\clearpage
\bibliography{coursework}{}
\bibliographystyle{gost71u}


\end{document}
